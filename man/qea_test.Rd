% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/qea_test.R
\name{qea_test}
\alias{qea_test}
\title{Quantitative Enrichment Analysis (QEA / MSEA)}
\usage{
qea_test(
  eset,
  scores,
  nperm = 1000,
  p_adjust = "BH",
  min_set_size = 3,
  max_set_size = 500,
  return_profiles = FALSE,
  quiet = TRUE
)
}
\arguments{
\item{eset}{An \code{EnrichmentSet} object containing the mapping from set
identifiers to feature IDs.}

\item{scores}{A named numeric vector of scores for all features. The
\strong{names} must be feature identifiers (e.g., PubChem, HMDB) and
must be comparable to the feature IDs stored in \code{eset}. The vector
will be internally sorted in decreasing order.}

\item{nperm}{Integer. Number of permutations used to estimate empirical
p-values (default \code{1000}). Set to \code{0} to skip permutation-based
p-values (p-values will be \code{NA}).}

\item{p_adjust}{Character string specifying the multiple testing correction
method to apply to the permutation p-values. Passed to
\code{\link[stats]{p.adjust}} (default \code{"BH"}).}

\item{min_set_size}{Minimum number of overlapping features required for a
set to be tested (default \code{3}).}

\item{max_set_size}{Maximum number of overlapping features allowed for a
set to be tested (default \code{500}).}

\item{return_profiles}{Logical; if \code{TRUE}, the function also returns
the running-score profile for each tested set (useful for plotting
enrichment profiles). Default \code{FALSE}.}

\item{quiet}{Logical; if \code{FALSE}, progress information is printed
(number of tested and skipped sets, etc.). Default \code{TRUE}.}
}
\value{
An object of class \code{"QEAResult"}, which is a list with:
\itemize{
\item \code{table}: a \code{data.frame} with one row per tested set, with
columns \code{set_id}, \code{set_name}, \code{n_in_set},
\code{ES}, \code{direction}, \code{p_value}, \code{p_adj}.
\item \code{profiles} (optional): if \code{return_profiles = TRUE}, a
named list of \code{data.frame}s with the running-score profile
(columns \code{set_id}, \code{position}, \code{running_score},
\code{hit}, \code{set_name}) for each tested set.
}
}
\description{
Perform a quantitative enrichment analysis on a ranked list of features
(e.g., metabolites) using a running-score statistic similar to GSEA.
}
\details{
Given an \code{EnrichmentSet} object and a named numeric vector of scores
(typically log2 fold changes, t-statistics, or other ranking measures),
this function computes an enrichment score (ES) for each set and an
empirical p-value based on permutations.

For each set, the function:
\enumerate{
\item Intersects the set features with the ranked universe (names of
\code{scores}) and filters by \code{min_set_size} and
\code{max_set_size}.
\item Computes a running-score profile where hits increase the score
by \code{1/Nh} and misses decrease it by \code{1/(N - Nh)},
with \code{Nh} the number of hits and \code{N} the total number
of ranked features.
\item Defines the observed Enrichment Score (ES) as the maximum (or
minimum, for negative enrichment) of the running-score profile.
\item Estimates a permutation-based p-value by comparing the observed
ES to the ES distribution obtained by random permutations of
feature positions.
}

The resulting table includes the set identifier, set name, set size,
ES, enrichment direction (positive/negative), raw p-value and adjusted
p-value, and is sorted by \code{p_value}.
}
\examples{
\dontrun{
# Toy example
meta <- list(
  mapping_name    = "toy_QEA",
  feature_id_type = "HMDB",
  feature_species = "Homo sapiens",
  set_source      = "ExampleDB",
  version         = "v1",
  description     = "Toy example for QEA"
)

df <- data.frame(
  set_id     = c("A", "B"),
  set_name   = c("Pathway A", "Pathway B"),
  feature_ids = c("x1;x2;x3;x4", "x3;x4;x5;x6")
)

eset <- EnrichmentSet(df, meta)
scores <- c(x1 = 2.0, x2 = 1.5, x3 = -1.0, x4 = 0.5,
            x5 = -2.5, x6 = -1.8)

res <- qea_test(eset, scores, nperm = 100, quiet = FALSE)
head(res$table)
}

}
